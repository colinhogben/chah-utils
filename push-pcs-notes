#!/usr/bin/perl
#=======================================================================
#	Ensure any recent changes to PcsNotes are checked in and pushed
#	Run by a cron job on freia023
#=======================================================================
use strict;
use Getopt::Long;
use POSIX qw(strftime);

my $TOOLSDIR = "$ENV{HOME}/pcsnotes";
my @NOTES = qw(PcsNotes
	       RtCpu HostCpu Realtime
	       Memory Symbols);

my($no_action);

sub main {
    GetOptions('n|no-action' => \$no_action)
	and @ARGV == 0
	or die "Usage: $0 [-n]\n";
    chdir $TOOLSDIR || die "Cannot cd $TOOLSDIR: $!\n";

    # Suppress sshd banner "ssh keys are required ..."
    $::ENV{GIT_SSH_COMMAND} = 'ssh -q';

    chomp(my $branch = `git rev-parse --abbrev-ref HEAD`);
    dbg("branch=$branch");

    my(@notes_mod,@index_dirty);
    open(my $git, '-|', 'git', 'status', '--porcelain')
	or die "Cannot open pipe from git status: $!\n";
    while (<$git>) {
	dbg($_);
	if (my($index,$work,$file) = /^(.)(.) (.*)/) {
	    foreach my $note (@NOTES) {
		if ($file eq $note) {
		    if ("$index$work" =~ /M/) {
			push @notes_mod, $note;
		    }
		} else {
		    if ($index =~ /[A-Z]/) {
			push @index_dirty, $note;
		    }
		}
	    }
	}
    }
    close($git)
	or die "Error closing pipe from git status: $!\n";

    my $mods = join(',', @notes_mod);
    if (@notes_mod) {
	if (@index_dirty) {
	    die "Updates to $mods, but git index is not clean\n";
	} elsif ($branch ne 'master') {
	    die "Updates tp $mods, but not on master branch: $branch\n";
	}
    }
    if (@notes_mod && ! @index_dirty) {
	check_command(['git', 'add', @notes_mod]);

	my $mtime;
	foreach my $note (@notes_mod) {
	    my $note_mtime = (stat "$TOOLSDIR/$note")[9];
	    $mtime = $note_mtime if $note_mtime > $mtime;
	}
	my $isodate = strftime "%Y-%m-%d", localtime $mtime;
	check_command(['git', 'commit',
		       '--date', $mtime,
		       "-m$mods: Update to $isodate"]);

	my($bindir) = ($0 =~ m!(.*/)!);
	my @filter = ("${bindir}efilter",'-v','^ssh keys are required');
	check_command([@filter,
		       'git', 'push', '--quiet']);
    }
}

sub check_command {
    my($cmd) = @_;
    if ($no_action) {
	print join(' ', map {&shellquote($_)} @$cmd),"\n";
	return;
    }
    open(my $pipe, '-|', @$cmd)
	or die "Error opening pipe from @$cmd: $!\n";
    my $out;
    while (<$pipe>) {
	$out .= $_;
	dbg($_);
    }
    close($pipe)
	or die "Error closing pipe from @$cmd: $!\n";
}

sub shellquote {
    my($term) = @_;
    return $term
	if $term =~ m#^[-\w,\.\+:@%/]+$#s;
    $term =~ s#'#'"'"'#gs;
    return "'$term'";
}

sub dbg {
    chomp(my $line = join('', @_));
    ## print STDERR "$line\n";
}

main;
